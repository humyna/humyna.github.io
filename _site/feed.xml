<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-12-18T07:23:55+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Humyna’s Blog</title><subtitle>技术.</subtitle><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2018/12/18/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-12-18T06:38:29+08:00</published><updated>2018-12-18T06:38:29+08:00</updated><id>http://localhost:4000/jekyll/update/2018/12/18/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/12/18/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">IP</title><link href="http://localhost:4000/blog/2018/09/29/new-born.html" rel="alternate" type="text/html" title="IP" /><published>2018-09-29T00:00:00+08:00</published><updated>2018-09-29T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/09/29/new-born</id><content type="html" xml:base="http://localhost:4000/blog/2018/09/29/new-born.html">&lt;h3 id=&quot;im-back&quot;&gt;I’m back!&lt;/h3&gt;</content><author><name></name></author><category term="blog" /><category term="IP" /><summary type="html">I’m back!</summary></entry><entry><title type="html">git 跨库push代码(A100技术笔记第1天)</title><link href="http://localhost:4000/blog/2015/05/19/push-mutil-repo.html" rel="alternate" type="text/html" title="git 跨库push代码(A100技术笔记第1天)" /><published>2015-05-19T00:00:00+08:00</published><updated>2015-05-19T00:00:00+08:00</updated><id>http://localhost:4000/blog/2015/05/19/push-mutil-repo</id><content type="html" xml:base="http://localhost:4000/blog/2015/05/19/push-mutil-repo.html">&lt;h3 id=&quot;场景&quot;&gt;场景&lt;/h3&gt;

&lt;p&gt;项目代码从团队自己搭建的git库(A库)切换到基于gitlab的git库(B库),因此我在本地开发的代码需要提交到新库(B库)。&lt;/p&gt;

&lt;h3 id=&quot;具体操作步骤&quot;&gt;具体操作步骤&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;本地仓库与远程仓库建立连接&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;humyna@god:~/gitpushtest$ git remote add gitlab_repo git@11.11.11.11:gittest/mygit.git&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;列出已经存在的远程分支&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;humyna@god:~/gitpushtest$ git remote -v&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git_repo git@10.10.10.10:gittest/mygit.git (fetch)
git_repo git@10.10.10.10:gittest/mygit.git (push)
gitlab_repo git@11.11.11.11:gittest/mygit.git (fetch)
gitlab_repo git@11.11.11.11:gittest/mygit.git (push)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;检查当前状态&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;humyna@god:~/gitpushtest$ git status&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;位于分支 dev1
您的分支与上游分支 'git_repo/dev1' 一致。

无文件要提交，干净的工作区
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;将本地的提交push到gitlab的dev1分支上(注意：此处由于gitlab_repo上dev1分支的代码是基于本地上一个提交的代码，故不存在merge等操作，否则需要fetch–&amp;gt;merge–&amp;gt;push)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;humyna@god:~/gitpushtest$ git push gitlab_repo dev1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Counting objects: 80, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (30/30), done.
Writing objects: 100% (46/46), 8.24 KiB | 0 bytes/s, done.
Total 46 (delta 17), reused 0 (delta 0)
To git@11.11.11.11:gittest/mygit.git
   		99a59be..6b0cf26  dev1-&amp;gt; dev1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;1.由于公司项目设计机密，就不发gitlab的提交成功截图了，另地址和显示均作了替换处理&lt;/p&gt;

&lt;p&gt;2.git_repo只是git@10.10.10.10:gittest/mygit.git的别名而已，只要保证多个远程库别名不重复即可&lt;/p&gt;

&lt;p&gt;3.以上思路也可用于同时push代码到多个远程库中，如下就是将代码同时push到git_repo和gitlab_repo的dev1分支&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git push git_repo dev1
git push gitlab_repo dev1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;—-EOF—-&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="git" /><category term="push" /><summary type="html">场景 项目代码从团队自己搭建的git库(A库)切换到基于gitlab的git库(B库),因此我在本地开发的代码需要提交到新库(B库)。 具体操作步骤 本地仓库与远程仓库建立连接 humyna@god:~/gitpushtest$ git remote add gitlab_repo git@11.11.11.11:gittest/mygit.git 列出已经存在的远程分支 humyna@god:~/gitpushtest$ git remote -v git_repo git@10.10.10.10:gittest/mygit.git (fetch) git_repo git@10.10.10.10:gittest/mygit.git (push) gitlab_repo git@11.11.11.11:gittest/mygit.git (fetch) gitlab_repo git@11.11.11.11:gittest/mygit.git (push) 检查当前状态 humyna@god:~/gitpushtest$ git status 位于分支 dev1 您的分支与上游分支 'git_repo/dev1' 一致。 无文件要提交，干净的工作区 将本地的提交push到gitlab的dev1分支上(注意：此处由于gitlab_repo上dev1分支的代码是基于本地上一个提交的代码，故不存在merge等操作，否则需要fetch–&amp;gt;merge–&amp;gt;push) humyna@god:~/gitpushtest$ git push gitlab_repo dev1 Counting objects: 80, done. Delta compression using up to 4 threads. Compressing objects: 100% (30/30), done. Writing objects: 100% (46/46), 8.24 KiB | 0 bytes/s, done. Total 46 (delta 17), reused 0 (delta 0) To git@11.11.11.11:gittest/mygit.git 99a59be..6b0cf26 dev1-&amp;gt; dev1 注意 1.由于公司项目设计机密，就不发gitlab的提交成功截图了，另地址和显示均作了替换处理 2.git_repo只是git@10.10.10.10:gittest/mygit.git的别名而已，只要保证多个远程库别名不重复即可 3.以上思路也可用于同时push代码到多个远程库中，如下就是将代码同时push到git_repo和gitlab_repo的dev1分支 git push git_repo dev1 git push gitlab_repo dev1 —-EOF—-</summary></entry><entry><title type="html">memcached入门(H1技术笔记第1天)</title><link href="http://localhost:4000/blog/2015/01/26/memcached-getting-started.html" rel="alternate" type="text/html" title="memcached入门(H1技术笔记第1天)" /><published>2015-01-26T00:00:00+08:00</published><updated>2015-01-26T00:00:00+08:00</updated><id>http://localhost:4000/blog/2015/01/26/memcached-getting-started</id><content type="html" xml:base="http://localhost:4000/blog/2015/01/26/memcached-getting-started.html">&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started&lt;/h2&gt;

&lt;h3 id=&quot;下载&quot;&gt;下载&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://memcached.org/downloads&quot;&gt;下载地址&lt;/a&gt;，最新版本为1.4.22&lt;/p&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Debian/Ubuntu: apt-get install libevent-dev&lt;/li&gt;
  &lt;li&gt;Redhat/Centos: yum install libevent-devel&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;wget http://memcached.org/latest&lt;/p&gt;

  &lt;p&gt;tar -zxvf memcached-1.x.x.tar.gz&lt;/p&gt;

  &lt;p&gt;cd memcached-1.x.x&lt;/p&gt;

  &lt;p&gt;./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; sudo make install&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;启动&quot;&gt;启动&lt;/h3&gt;
&lt;p&gt;./memcached -d -m 1024 -l localhost -p 11211&lt;/p&gt;

&lt;p&gt;这会以守护程序的形式启动 memcached（-d），为其分配 1GB 内存（-m 1024），并指定监听 localhost，即端口 11211。&lt;/p&gt;

&lt;h3 id=&quot;连接到memcached&quot;&gt;连接到memcached&lt;/h3&gt;
&lt;p&gt;telnet localhost 11211&lt;/p&gt;

&lt;p&gt;如果一切正常，则应该得到一个 telnet 响应，它会指示 Connected to localhost（已经连接到 localhost）。&lt;/p&gt;

&lt;h3 id=&quot;常用命令说明&quot;&gt;常用命令说明&lt;/h3&gt;
&lt;p&gt;启动/结束
memcached -d -m 10 -u root -l localhost -p 11211 -c 256 -P /tmp/memcached.pid&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;-d 选项是启动一个守护进程，&lt;/li&gt;
  &lt;li&gt;-m 是分配给Memcache使用的内存数量，单位是MB，这里是10MB&lt;/li&gt;
  &lt;li&gt;-u 是运行Memcache的用户，这里是root&lt;/li&gt;
  &lt;li&gt;-l 是监听的服务器IP地址，如果有多个地址的话，这里指定了服务器的IP地址localhost&lt;/li&gt;
  &lt;li&gt;-p 是设置Memcache监听的端口，这里设置了12000，最好是1024以上的端口&lt;/li&gt;
  &lt;li&gt;-c 选项是最大运行的并发连接数，默认是1024，这里设置了256，按照服务器的负载量来设定&lt;/li&gt;
  &lt;li&gt;-P 是设置保存Memcache的pid文件&lt;/li&gt;
  &lt;li&gt;kill &lt;code class=&quot;highlighter-rouge&quot;&gt;cat /tmp/memcached.pid&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;获取运行状态&quot;&gt;获取运行状态&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;echo stats&lt;/td&gt;
          &lt;td&gt;nc localhost 11211&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;watch “echo stats&lt;/td&gt;
          &lt;td&gt;nc localhost 11211” (实时状态)&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;客户端命令详解&quot;&gt;客户端命令详解&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;9 个memcached客户端命令可以分为三类：基本、高级、管理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;基本memcached客户端命令&quot;&gt;基本memcached客户端命令&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;set、add、replace、get、delete&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ol&gt;
  &lt;li&gt;前三个命令是用于操作存储在 memcached 中的键值对的标准修改命令。&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;修改命令语法&quot;&gt;修改命令语法&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;lt;key&amp;gt; &amp;lt;flags&amp;gt; &amp;lt;expiration time&amp;gt; &amp;lt;bytes&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;value&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;修改命令参数说明&quot;&gt;修改命令参数说明&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;key 用于查找缓存值&lt;/li&gt;
  &lt;li&gt;flags 可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息&lt;/li&gt;
  &lt;li&gt;expiration time 在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）&lt;/li&gt;
  &lt;li&gt;bytes 在缓存中存储的字节点&lt;/li&gt;
  &lt;li&gt;value 存储的值（始终位于第二行）&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;set&quot;&gt;set&lt;/h5&gt;

&lt;p&gt;set 命令用于向缓存添加新的键值对。如果键已经存在，则之前的值将被替换。&lt;/p&gt;

&lt;h5 id=&quot;add&quot;&gt;add&lt;/h5&gt;

&lt;p&gt;仅当缓存中不存在键时，add 命令才会向缓存中添加一个键值对。如果缓存中已经存在键，则之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。&lt;/p&gt;

&lt;h5 id=&quot;replace&quot;&gt;replace&lt;/h5&gt;

&lt;p&gt;仅当键已经存在时，replace 命令才会替换缓存中的键。如果缓存中不存在键，那么您将从 memcached 服务器接受到一条 NOT_STORED 响应。&lt;/p&gt;

&lt;p&gt;后两个基本命令get和delete的语法&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;command &amp;lt;key&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;get&quot;&gt;get&lt;/h5&gt;

&lt;h5 id=&quot;delete&quot;&gt;delete&lt;/h5&gt;

&lt;h3 id=&quot;高级memcached客户端命令&quot;&gt;高级memcached客户端命令&lt;/h3&gt;

&lt;p&gt;可以在memcached中使用的两个高级命令是gets和cas。gets和cas命令需要结合使用。使用这两个命令来确保不会将现有的名称/值对设置为新值（如果该值已经更新过）。&lt;/p&gt;

&lt;h5 id=&quot;gets&quot;&gt;gets&lt;/h5&gt;

&lt;p&gt;gets命令的功能类似于基本的get命令。两个命令之间的差异在于，gets返回的信息稍微多一些：64位的整型值非常像名称/值对的“版本”标识符。&lt;/p&gt;

&lt;p&gt;gets命令将返回一个额外的值，用于标识名称/值对。如果对此名称/值对执行另一个set命令，则gets 返回的额外值将会发生更改，以表明名称/值对已经被更新。&lt;/p&gt;

&lt;h5 id=&quot;cas&quot;&gt;cas&lt;/h5&gt;

&lt;p&gt;cas（check和set）是一个非常便捷的memcached命令，用于设置名称/值对的值（如果该名称/值对在您上次执行gets后没有更新过）。它使用与 set 命令相类似的语法，但包括一个额外的值：gets返回的额外值。&lt;/p&gt;

&lt;p&gt;从本质上说，同时使用 gets和 cas命令可以防止使用自上次读取后经过更新的名称/值对。&lt;/p&gt;

&lt;h3 id=&quot;缓存管理命令&quot;&gt;缓存管理命令&lt;/h3&gt;
&lt;p&gt;最后两个memcached命令用于监控和清理memcached实例。它们是stats和flush_all命令。&lt;/p&gt;

&lt;h5 id=&quot;stats&quot;&gt;stats&lt;/h5&gt;

&lt;p&gt;stats 命令的功能正如其名：转储所连接的 memcached 实例的当前统计数据。&lt;/p&gt;

&lt;h5 id=&quot;flush_all&quot;&gt;flush_all&lt;/h5&gt;

&lt;p&gt;flush_all 是最后一个要介绍的命令。这个最简单的命令仅用于清理缓存中的所有名称/值对。如果您需要将缓存重置到干净的状态，则 flush_all 能提供很大的用处。&lt;/p&gt;

&lt;h2 id=&quot;缓存性能&quot;&gt;缓存性能&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;使用高级 memcached 命令来确定缓存的性能。&lt;/p&gt;

  &lt;p&gt;stats 命令用于调优缓存的使用。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;有两种方法用于确定缓存的效率&quot;&gt;有两种方法用于确定缓存的效率&lt;/h3&gt;

&lt;h4 id=&quot;方法一&quot;&gt;方法一&lt;/h4&gt;

&lt;p&gt;需要注意的两个最重要的统计数据是get_hits和get_misses。这两个值分别指示找到名称/值对的次数（get_hits）和未找到名称/值对的次数（get_misses）。结合这些值，我们可以确定缓存的利用率如何。&lt;/p&gt;

&lt;p&gt;初次启动缓存时，可以看到get_misses会自然地增加，但在经过一定的使用量之后，这些get_misses值应该会逐渐趋于平稳 — 这表示缓存主要用于常见的读取操作。&lt;/p&gt;

&lt;p&gt;如果看到get_misses继续快速增加，而get_hits逐渐趋于平稳，则需要确定一下所缓存的内容是什么。可能缓存了错误的内容。&lt;/p&gt;

&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;

&lt;p&gt;查看缓存的命中率（hit ratio）。缓存命中率表示执行get的次数与错过get的次数的百分比。要确定这个百分比，需要运行stats命令，用get_hits的数值除以cmd_gets。&lt;/p&gt;

&lt;p&gt;在理想情况下，可能希望得到更高的百分比—比率越高越好。查看统计数据并不时测量它们可以很好地判定缓存策略的效率。&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="memcached" /><summary type="html">Getting Started 下载 下载地址，最新版本为1.4.22 安装 Debian/Ubuntu: apt-get install libevent-dev Redhat/Centos: yum install libevent-devel wget http://memcached.org/latest tar -zxvf memcached-1.x.x.tar.gz cd memcached-1.x.x ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make test &amp;amp;&amp;amp; sudo make install 启动 ./memcached -d -m 1024 -l localhost -p 11211 这会以守护程序的形式启动 memcached（-d），为其分配 1GB 内存（-m 1024），并指定监听 localhost，即端口 11211。 连接到memcached telnet localhost 11211 如果一切正常，则应该得到一个 telnet 响应，它会指示 Connected to localhost（已经连接到 localhost）。 常用命令说明 启动/结束 memcached -d -m 10 -u root -l localhost -p 11211 -c 256 -P /tmp/memcached.pid -d 选项是启动一个守护进程， -m 是分配给Memcache使用的内存数量，单位是MB，这里是10MB -u 是运行Memcache的用户，这里是root -l 是监听的服务器IP地址，如果有多个地址的话，这里指定了服务器的IP地址localhost -p 是设置Memcache监听的端口，这里设置了12000，最好是1024以上的端口 -c 选项是最大运行的并发连接数，默认是1024，这里设置了256，按照服务器的负载量来设定 -P 是设置保存Memcache的pid文件 kill cat /tmp/memcached.pid 获取运行状态 echo stats nc localhost 11211 watch “echo stats nc localhost 11211” (实时状态) 客户端命令详解 9 个memcached客户端命令可以分为三类：基本、高级、管理 基本memcached客户端命令 set、add、replace、get、delete 前三个命令是用于操作存储在 memcached 中的键值对的标准修改命令。 修改命令语法 command &amp;lt;key&amp;gt; &amp;lt;flags&amp;gt; &amp;lt;expiration time&amp;gt; &amp;lt;bytes&amp;gt; &amp;lt;value&amp;gt; 修改命令参数说明 key 用于查找缓存值 flags 可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 expiration time 在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes 在缓存中存储的字节点 value 存储的值（始终位于第二行） set set 命令用于向缓存添加新的键值对。如果键已经存在，则之前的值将被替换。 add 仅当缓存中不存在键时，add 命令才会向缓存中添加一个键值对。如果缓存中已经存在键，则之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。 replace 仅当键已经存在时，replace 命令才会替换缓存中的键。如果缓存中不存在键，那么您将从 memcached 服务器接受到一条 NOT_STORED 响应。 后两个基本命令get和delete的语法 command &amp;lt;key&amp;gt; get delete 高级memcached客户端命令 可以在memcached中使用的两个高级命令是gets和cas。gets和cas命令需要结合使用。使用这两个命令来确保不会将现有的名称/值对设置为新值（如果该值已经更新过）。 gets gets命令的功能类似于基本的get命令。两个命令之间的差异在于，gets返回的信息稍微多一些：64位的整型值非常像名称/值对的“版本”标识符。 gets命令将返回一个额外的值，用于标识名称/值对。如果对此名称/值对执行另一个set命令，则gets 返回的额外值将会发生更改，以表明名称/值对已经被更新。 cas cas（check和set）是一个非常便捷的memcached命令，用于设置名称/值对的值（如果该名称/值对在您上次执行gets后没有更新过）。它使用与 set 命令相类似的语法，但包括一个额外的值：gets返回的额外值。 从本质上说，同时使用 gets和 cas命令可以防止使用自上次读取后经过更新的名称/值对。 缓存管理命令 最后两个memcached命令用于监控和清理memcached实例。它们是stats和flush_all命令。 stats stats 命令的功能正如其名：转储所连接的 memcached 实例的当前统计数据。 flush_all flush_all 是最后一个要介绍的命令。这个最简单的命令仅用于清理缓存中的所有名称/值对。如果您需要将缓存重置到干净的状态，则 flush_all 能提供很大的用处。 缓存性能 使用高级 memcached 命令来确定缓存的性能。 stats 命令用于调优缓存的使用。 有两种方法用于确定缓存的效率 方法一 需要注意的两个最重要的统计数据是get_hits和get_misses。这两个值分别指示找到名称/值对的次数（get_hits）和未找到名称/值对的次数（get_misses）。结合这些值，我们可以确定缓存的利用率如何。 初次启动缓存时，可以看到get_misses会自然地增加，但在经过一定的使用量之后，这些get_misses值应该会逐渐趋于平稳 — 这表示缓存主要用于常见的读取操作。 如果看到get_misses继续快速增加，而get_hits逐渐趋于平稳，则需要确定一下所缓存的内容是什么。可能缓存了错误的内容。 方法二 查看缓存的命中率（hit ratio）。缓存命中率表示执行get的次数与错过get的次数的百分比。要确定这个百分比，需要运行stats命令，用get_hits的数值除以cmd_gets。 在理想情况下，可能希望得到更高的百分比—比率越高越好。查看统计数据并不时测量它们可以很好地判定缓存策略的效率。</summary></entry><entry><title type="html">git cherry-pick使用场景</title><link href="http://localhost:4000/blog/2015/01/07/git-cherry-pick.html" rel="alternate" type="text/html" title="git cherry-pick使用场景" /><published>2015-01-07T14:55:13+08:00</published><updated>2015-01-07T14:55:13+08:00</updated><id>http://localhost:4000/blog/2015/01/07/git-cherry-pick</id><content type="html" xml:base="http://localhost:4000/blog/2015/01/07/git-cherry-pick.html">&lt;ul&gt;
  &lt;li&gt;git cherry-pick用法&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;git cherry-pick commit_id1 commit_id2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;功能说明&lt;/p&gt;

    &lt;p&gt;“复制”一个或多个已提交节点并在当前分支做一次完全一样的新提交，这个新的提交的哈希值和原来的不同，但标识名一样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;功能示意图&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://i.imgur.com/YWowgd7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用场景&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们在dev1上进行bug修复，并作了一次提交，然后被告知，“抱歉，今天需要紧急上线dev1分支代码，你这个bug没有时间测试，需要将这次提交移到dev2分支上进行测试。“ 这时候就是cherry-pick显神威的地方了。
可以进行如下操作:&lt;/p&gt;

&lt;p&gt;1.切换到dev2分支，注意需要确保dev2分支干净&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout dev2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2.然后执行cherry-pick命令&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git cherry-pick commit_id&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;3.对于dev1分支的提交，切换到执行revert命令,撤销此次提交&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;git checkout dev1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;git revert &lt;commit&gt;&lt;/commit&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;(完)
本文使用MarkdownPad 2编辑完成&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="git" /><category term="cherry-pick" /><summary type="html">git cherry-pick用法 git cherry-pick commit_id1 commit_id2 功能说明 “复制”一个或多个已提交节点并在当前分支做一次完全一样的新提交，这个新的提交的哈希值和原来的不同，但标识名一样 功能示意图 使用场景 我们在dev1上进行bug修复，并作了一次提交，然后被告知，“抱歉，今天需要紧急上线dev1分支代码，你这个bug没有时间测试，需要将这次提交移到dev2分支上进行测试。“ 这时候就是cherry-pick显神威的地方了。 可以进行如下操作: 1.切换到dev2分支，注意需要确保dev2分支干净 git checkout dev2 2.然后执行cherry-pick命令 git cherry-pick commit_id 3.对于dev1分支的提交，切换到执行revert命令,撤销此次提交 git checkout dev1 git revert (完) 本文使用MarkdownPad 2编辑完成</summary></entry><entry><title type="html">Humyna’s CV</title><link href="http://localhost:4000/blog/2014/05/01/my-cv.html" rel="alternate" type="text/html" title="Humyna's CV" /><published>2014-05-01T00:00:00+08:00</published><updated>2014-05-01T00:00:00+08:00</updated><id>http://localhost:4000/blog/2014/05/01/my-cv</id><content type="html" xml:base="http://localhost:4000/blog/2014/05/01/my-cv.html">&lt;h2 id=&quot;联系我&quot;&gt;联系我&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;WeChat:@humyna&lt;/li&gt;
  &lt;li&gt;Email:hufo125 # gmail.com(使用@代替#)&lt;/li&gt;
  &lt;li&gt;WebSite:http://humyna.github.io&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;技术经验&quot;&gt;技术经验&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;5年编程经验&lt;/li&gt;
  &lt;li&gt;语言：Java、SQL、javascript、PHP&lt;/li&gt;
  &lt;li&gt;版本控制：git、svn&lt;/li&gt;
  &lt;li&gt;测试驱动开发：Junit&lt;/li&gt;
  &lt;li&gt;数据库：Oracle、MySQL&lt;/li&gt;
  &lt;li&gt;操作系统：ubuntu12.04、Windows7&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;项目经验&quot;&gt;项目经验&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2013.01-至今 互联网金融之P2P  研发工程师
  职责:1.负责核心功能的设计与开发; 2.项目规范的制定与编写&lt;/li&gt;
  &lt;li&gt;2009.7-2012.12 电信行业 Java研发工程师
  职责:负责接口模块的设计与开发&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;教育&quot;&gt;教育&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;2005.7-2009.7 哈尔滨工程大学(221)
  计算机科学与技术专业(平均学分:86 排名:19/220)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;兴趣爱好&quot;&gt;兴趣爱好&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;爱自由:fuck gfw&lt;/li&gt;
  &lt;li&gt;晨型人:爱生活&lt;/li&gt;
  &lt;li&gt;跑步  :Just For 2014 Beijing Marathon&lt;/li&gt;
  &lt;li&gt;阅读  :保持至少每周1本书&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;————————-EOF————————-&lt;/p&gt;</content><author><name></name></author><category term="blog" /><category term="cv" /><category term="简历" /><summary type="html">联系我 WeChat:@humyna Email:hufo125 # gmail.com(使用@代替#) WebSite:http://humyna.github.io 技术经验 5年编程经验 语言：Java、SQL、javascript、PHP 版本控制：git、svn 测试驱动开发：Junit 数据库：Oracle、MySQL 操作系统：ubuntu12.04、Windows7 项目经验 2013.01-至今 互联网金融之P2P 研发工程师 职责:1.负责核心功能的设计与开发; 2.项目规范的制定与编写 2009.7-2012.12 电信行业 Java研发工程师 职责:负责接口模块的设计与开发 教育 2005.7-2009.7 哈尔滨工程大学(221) 计算机科学与技术专业(平均学分:86 排名:19/220) 兴趣爱好 爱自由:fuck gfw 晨型人:爱生活 跑步 :Just For 2014 Beijing Marathon 阅读 :保持至少每周1本书 ————————-EOF————————-</summary></entry><entry><title type="html">[最佳实践]Windows7下搭建写博环境</title><link href="http://localhost:4000/blog/2014/03/16/blogging-based-on-jekyll.html" rel="alternate" type="text/html" title="[最佳实践]Windows7下搭建写博环境" /><published>2014-03-16T00:00:00+08:00</published><updated>2014-03-16T00:00:00+08:00</updated><id>http://localhost:4000/blog/2014/03/16/blogging-based-on-jekyll</id><content type="html" xml:base="http://localhost:4000/blog/2014/03/16/blogging-based-on-jekyll.html">&lt;h2 id=&quot;软件下载&quot;&gt;软件下载&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Windows 7 64bit&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://rubyforge.org/frs/download.php/76054/rubyinstaller-1.9.3-p194.exe&quot;&gt;RubyInstaller 1.9.3&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/oneclick/rubyinstaller/downloads/&quot;&gt;DevKit-DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Jekyll 1.4.2&lt;/li&gt;
  &lt;li&gt;Rdiscount&lt;/li&gt;
  &lt;li&gt;Github客户端&lt;/li&gt;
  &lt;li&gt;Gvim7.3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;安装配置&quot;&gt;安装配置&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;1.下载RubyInstaller并安装，然后在命令行终端下输入gem update –system来升级gem，然后分别输入ruby -v和gem -v检验安装版本&lt;/li&gt;
  &lt;li&gt;2.下载最新的DevKit(DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。这个方法目前仅支持通过RubyInstaller安装的Ruby)并双击运行解压到C:\DevKit。然后打开终端cmd，输入下列命令进行安装：
  cd C:\DevKit
  ruby dk.rb init
  ruby dk.rb install&lt;/li&gt;
  &lt;li&gt;3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem):
  gem install Jekyll –version “=1.4.2”&lt;/li&gt;
  &lt;li&gt;4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令：
  gem install rdiscount&lt;/li&gt;
  &lt;li&gt;5.安装Github on windows，安装完桌面有Github和git shell两个快捷方式&lt;/li&gt;
  &lt;li&gt;6.安装Gvim7.3，并配置markdown插件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;写作环境搭建&quot;&gt;写作环境搭建&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.在github.com注册账号
2.创建名为humyna.github.io的仓库
3.Clone in Desktop
4.打开git shell,使用如下命令clone Jekyll-Bootstrap到本地
git clone https://github.com/plusjade/jekyll-bootstrap.git Jekyll-Bootstrap
5.将Jekyll-Bootstrap文件夹中除.git外的所有文件copy到humyna.github.io文件夹中
6.修改_config.yml中相关的配置，设置博客主题
7.在git shell中，cd到humyna.github.io文件夹下，执行命令jekyll serve --watch(不加--watch则不会检测文件夹内的变化，即修改后需要重新启动jekyll),即可以通过http://localhost:4000访问本地的博客环境
8.执行rake post title=&quot;hello world&quot;即可在_posts文件夹下生成一个md文件，使用vim编辑进行博客创作，保存后可以在浏览器中看到效果。
9.完成写作后，使用github的客户端完成提交，这样就能将完成的博文发布到网上(humyna.github.io)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;注意事项&quot;&gt;注意事项&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.Ruby默认安装后在用户环境变量中已添加（path=C:\Ruby193\bin）无需再配置
2.Ruby和DevKit解压路径不能有空格
3.Jekyll应该安装1.4.2版本(使用jekyll -v检查是否安装成功)并配置用户环境变量解决中文编码问题LC_ALL=en_US.UTF-8和Lang=en_US.UTF-8
如果此时使用gem 安装软件会报错：
ERROR:  While executing gem ... (ArgumentError)
invalid byte sequence in UTF-8
需要先删除这两个环境变量，等完装完再加上。
4.Gvim需要设置默认编码为utf-8,不然打开含有中文文件会有乱码
5.可以绑定自己的域名，在根目录下闯将CNAME文件并将域名加进去，同时配置域名映射即可。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="blog" /><category term="jekyll" /><summary type="html">软件下载 Windows 7 64bit RubyInstaller 1.9.3 DevKit-DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe Jekyll 1.4.2 Rdiscount Github客户端 Gvim7.3 安装配置 1.下载RubyInstaller并安装，然后在命令行终端下输入gem update –system来升级gem，然后分别输入ruby -v和gem -v检验安装版本 2.下载最新的DevKit(DevKit是windows平台下编译和使用本地C/C++扩展包的工具。它就是用来模拟Linux平台下的make,gcc,sh来进行编译。这个方法目前仅支持通过RubyInstaller安装的Ruby)并双击运行解压到C:\DevKit。然后打开终端cmd，输入下列命令进行安装： cd C:\DevKit ruby dk.rb init ruby dk.rb install 3.完成上面的准备就可以安装Jekyll了,因为Jekyll是用Ruby编写的,最好的安装方式是通过RubyGems(gem): gem install Jekyll –version “=1.4.2” 4.安装Rdiscount，这个用来解析Markdown标记的包，使用如下命令： gem install rdiscount 5.安装Github on windows，安装完桌面有Github和git shell两个快捷方式 6.安装Gvim7.3，并配置markdown插件 写作环境搭建 1.在github.com注册账号 2.创建名为humyna.github.io的仓库 3.Clone in Desktop 4.打开git shell,使用如下命令clone Jekyll-Bootstrap到本地 git clone https://github.com/plusjade/jekyll-bootstrap.git Jekyll-Bootstrap 5.将Jekyll-Bootstrap文件夹中除.git外的所有文件copy到humyna.github.io文件夹中 6.修改_config.yml中相关的配置，设置博客主题 7.在git shell中，cd到humyna.github.io文件夹下，执行命令jekyll serve --watch(不加--watch则不会检测文件夹内的变化，即修改后需要重新启动jekyll),即可以通过http://localhost:4000访问本地的博客环境 8.执行rake post title=&quot;hello world&quot;即可在_posts文件夹下生成一个md文件，使用vim编辑进行博客创作，保存后可以在浏览器中看到效果。 9.完成写作后，使用github的客户端完成提交，这样就能将完成的博文发布到网上(humyna.github.io) 注意事项 1.Ruby默认安装后在用户环境变量中已添加（path=C:\Ruby193\bin）无需再配置 2.Ruby和DevKit解压路径不能有空格 3.Jekyll应该安装1.4.2版本(使用jekyll -v检查是否安装成功)并配置用户环境变量解决中文编码问题LC_ALL=en_US.UTF-8和Lang=en_US.UTF-8 如果此时使用gem 安装软件会报错： ERROR: While executing gem ... (ArgumentError) invalid byte sequence in UTF-8 需要先删除这两个环境变量，等完装完再加上。 4.Gvim需要设置默认编码为utf-8,不然打开含有中文文件会有乱码 5.可以绑定自己的域名，在根目录下闯将CNAME文件并将域名加进去，同时配置域名映射即可。</summary></entry></feed>